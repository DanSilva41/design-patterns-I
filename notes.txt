Book:
    Design Patterns - Elements of Reusable Object-Oriented Software - 1994
    Erich Gamma, Richard Helm, Ralph Johnson, John Vissides (Ganf of Four)

23 padrões de projeto
3 categorias:

    * Criacionais: Cujo foco é na criação, construção de objetos
    * Estruturais: Focados em composição e estruturais entre objetos
    * COMPORTAMENTAIS: Focados nos métodos, estado e interação entr objetos

        - Strategy
            "Sugere que você pegue uma classe que faz algo específico de várias maneiras diferentes e
            extraia todos esses algoritmos em classes separadas chamadas de estratégias ."

            Para saber mais: https://refactoring.guru/design-patterns/strategy
                             https://refactoring.guru/design-patterns/strategy/java/example
        - Chain of Responsability
            "Depende da transformação de comportamentos específicos em objetos autônomos chamados de manipuladores.
            O padrão sugere que você conecte esses manipuladores em uma cadeia. Cada manipulador vinculado tem um campo
            para armazenar uma referência ao próximo manipulador na cadeia. Além de processar uma solicitação,
            os manipuladores passam a solicitação mais adiante na cadeia. A solicitação viaja ao longo da cadeia até que
            todos os manipuladores tenham a chance de processá-la."

            Para saber mais: https://refactoring.guru/design-patterns/chain-of-responsibility
                             https://refactoring.guru/design-patterns/chain-of-responsibility/java/example
        - Template Method
            "Favorece o reaproveitamento de códigos comuns entre classes, evitando assim duplicações de códigos."
            "Define o esqueleto de um algoritmo na superclasse, mas permite que as subclasses substituam etapas específicas
            do algoritmo sem alterar sua estrutura."

            "Sugere que você divida um algoritmo em uma série de etapas, transforme essas etapas em métodos e coloque
            uma série de chamadas para esses métodos dentro de um único método de modelo. As etapas podem ser abstract ou
            ter alguma implementação padrão. Para usar o algoritmo, o cliente deve fornecer sua própria subclasse,
            implementar todas as etapas abstratas e substituir algumas das opcionais, se necessário (mas não o método do modelo em si)."

            Para saber mais: https://refactoring.guru/design-patterns/template-method
                             https://refactoring.guru/design-patterns/template-method/java/example

        - State
            "A ideia principal é que, a qualquer momento, há um número finito de estados em que um programa pode estar.
            Em qualquer estado único, o programa se comporta de maneira diferente e pode ser comutado de um estado para outro instantaneamente.
            No entanto, dependendo do estado atual, o programa pode ou não mudar para outros estados.
            Essas regras de comutação, chamadas de transições , também são finitas e predeterminadas."

            "Este padrão, assim como o padrão Strategy, resolve o problema de muitos ifs no código."
            "Essa estrutura pode ser semelhante ao padrão Strategy , mas há uma diferença fundamental.
            No padrão State, os estados particulares podem estar cientes uns dos outros e iniciar transições de um estado para outro,
            ao passo que as estratégias quase nunca se conhecem."
            "Permite que um objeto altere seu comportamento quando seu estado interno muda."

            "Sugere que você crie novas classes para todos os estados possíveis de um objeto e extraia todos os comportamentos específicos de estado para essas classes."

            Para saber mais: https://refactoring.guru/design-patterns/state
                             https://refactoring.guru/design-patterns/state/java/example
        - Command
        - Observer

