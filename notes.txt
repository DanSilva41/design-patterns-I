Book:
    Design Patterns - Elements of Reusable Object-Oriented Software - 1994
    Erich Gamma, Richard Helm, Ralph Johnson, John Vissides (Ganf of Four)

23 padrões de projeto
3 categorias:

    * Criacionais: Cujo foco é na criação, construção de objetos
    * Estruturais: Focados em composição e estruturais entre objetos
    * COMPORTAMENTAIS: Focados nos métodos, estado e interação entr objetos

        - Strategy
            "Sugere que você pegue uma classe que faz algo específico de várias maneiras diferentes e
            extraia todos esses algoritmos em classes separadas chamadas de estratégias ."

            Para saber mais: https://refactoring.guru/design-patterns/strategy
                             https://refactoring.guru/design-patterns/strategy/java/example
        - Chain of Responsability
            "Depende da transformação de comportamentos específicos em objetos autônomos chamados de manipuladores.
            O padrão sugere que você conecte esses manipuladores em uma cadeia. Cada manipulador vinculado tem um campo
            para armazenar uma referência ao próximo manipulador na cadeia. Além de processar uma solicitação,
            os manipuladores passam a solicitação mais adiante na cadeia. A solicitação viaja ao longo da cadeia até que
            todos os manipuladores tenham a chance de processá-la."

            Para saber mais: https://refactoring.guru/design-patterns/chain-of-responsibility
                             https://refactoring.guru/design-patterns/chain-of-responsibility/java/example
        - Template Method
            "Favorece o reaproveitamento de códigos comuns entre classes, evitando assim duplicações de códigos."
            "Define o esqueleto de um algoritmo na superclasse, mas permite que as subclasses substituam etapas específicas
            do algoritmo sem alterar sua estrutura."

            "Sugere que você divida um algoritmo em uma série de etapas, transforme essas etapas em métodos e coloque
            uma série de chamadas para esses métodos dentro de um único método de modelo. As etapas podem ser abstract ou
            ter alguma implementação padrão. Para usar o algoritmo, o cliente deve fornecer sua própria subclasse,
            implementar todas as etapas abstratas e substituir algumas das opcionais, se necessário (mas não o método do modelo em si)."

            Para saber mais: https://refactoring.guru/design-patterns/template-method
                             https://refactoring.guru/design-patterns/template-method/java/example

        - State
        - Command
        - Observer

